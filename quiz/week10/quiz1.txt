아래의 주제에 대해 설명해주세요.
완전히 이해 한 후 설명해야 합니다.

1. 유저 모드, 커널 모드
CPU 는 컴퓨터 보안과 시스템 보호를 위해 커널 모드와 유저 모드, 두가지 프로세서 접근 모드로 나뉩니다.
커널모드는 그 자신인 커널 영역을 포함한 유저 영역까지 접근이 가능하고
유저모드는 접근 가능한 것이 유저 영역에 한정되어 있습니다.
커널모드는 모든 시스템 메모리에 접근 할 수 있으며 모든 명령 수행이 가능합니다.

2. 프로세스

프로그램은 보조기억장치에서 실행되기를 기다리는 명령어(코드)와 정적인 데이터의 묶음입니다.
프로그램의 명령어와 정적 데이터가 메모리에 적재 되면 프로세스가 됩니다.

 운영체제는 프로세스의 상태를 실행(running), 준비(ready), 블록(block) 상태로 분류하고 프로세스들을 상태전이를 통해 체계적으로 관리합니다.

가장 첫번째로 준비-실행의 경우, 준비상태에서 실행상태로 상태 전이한다고 표현을 합니다. 이 과정을 디스패칭이라고 하고 디스패쳐가 작업을 수행합니다.
  프로세스는 실행상태에서 CPU를 이용해 연산한 후 CPU를 자발적으로 반납하고 작업이 끝나지 않았으면 다시 준비상태에 들어갑니다.
운영체제는 다시 준비리스트의 첫번째에 있는 프로세스를 실행상태로 바꾸고 이 과정을 반복한다고 합니다.

  운영체제는 프로세스가 CPU를 반납하지 않고 독점하는 경우를 방지하기 위해 하드웨어상 '인터럽팅 클록'이라는 것을 주기적으로 발생시켜 프로세스가 특정 시간 간격동안만 실행할 수 있게 한다고 합니다.

   인터럽팅 클록이 발생되면 실행중인 프로세스의 CPU 제어권이 강제성에 의해 운영체제에게 빼앗기고 이때 프로세스는 준비상태로 상태 전이 됩니다.
 만약 프로세스를 다시 사용하기 전에 입출력이 완료대기를 기다려야 하는 상황이라면 완료될때까 자신을 '블록'합니다.
 입출력이 완료되면 운영체제가 프로세스를 블록상태에서 준비상태로 다시 전이 시킵니다.

여러 프로세스를 사용하는 것을 멀티 프로세싱, 동시간대에 여러 개의 프로그램을 띄우는 것을 멀티 태스킹이라고 하며
여러 프로세스를 일정 기준(스케줄링 알고리즘)으로 순서를 정해 실행하는 것을 스케줄링이라고 합니다.
 이때 스레드 단위로 스케줄링을 하며 프로세스는 최소 하나의 스레드를 가지고 있다고 합니다.

최초로 생성되는 init 프로세스를 제외하고 모든 프로세스는 부모 프로세스를 복제해서 생성되고, 이 계층관계는 트리를 형성합니다.
각 프로세스는 자식프로세스와 부모프로세스의 정보를 가지고 있습니다.

프로세스에 대한 정보는 프로세스 제어블록(PCB) 또는
process descriptor 라고 부르는 자료구조에 저장됩니다.
PCB에는 운영체제가 관리상 사용하는 정보가 들어있는데,
현재 프로세스의 각 상태, 프로세스 고유의 식별 번호인 ID(PID), 스케줄링의
우선순위에 대한 정보, program counter(CPU 가 다음으로 실행할 명령어가 저장된 메모리 값) 값, register 값,  CPU 수행에 관련된 각종 정보 등입니다.
또한 프로세스의 해당 프로그램에 대한 정보는 프로세스가 메모리에 가지는 자신만의 주소 공간에 저장 되는데, 이 공간에 대한 포인터 값을 가집니다.





3. 스레드

스레드는 프로세스 내부의 프로세스보다도 작은 실행 흐름의 최소 단위 입니다.
프로세스와 스레드의 다른 점은, 프로세스는 서로 완벽한 독립적인 공간을 가지고 각자가 각자의 스텍과 데이터 영역을 가지고, 보호를 받는데,
스레드는 각자가 각자의 스텍은 가지나, 데이터 영역은 하나를 공유합니다.
(프로세스 : 건강한 비글 3마리, 스레드 : 케르베로스 한마리 ; 라고 나무 위키에 좋은 비유가 나와 있습니다)
그래서 데이터 영역을 공유하는 스레드와는 다르게 프로세스는 프로세스 통신이라는 과정을 거쳐야 합니다.


3. 컨텍스트, 컨텍스트 스위칭

컨텍스트란 어떤 영역, 경계를 구분하는 데 쓰이거나, 이 영역이나 경계를 넘어갈때 전달해야 하는 데이터의 모음입니다.(객체)
컨텍스트 스위칭이란 한 프로세스가 CPU를 사용 중일때 다른 프로세스가 CPU를 사용하기 위해, 이전의 프로세스의 상태를 보관하고 새로운 프로세스 상태를 CPU에 적재하는것을 말합니다.

4. 레지스터

레지스터란 CPU 내부에서 처리할 명령어나 연산 값 등을 일시적으로 기억하는 임시기억장소이며, 메모리 중 속도가 가장 빠릅니다. 연산속도를 향상시키기 위해 사용한다고 합니다.

5. 캐시 히트, 캐시 미스

CPU가 데이터를 요청했을 때 캐시 메모리가 해당 데이터를 가지고 있다면 이를 캐시 히트라 부르고, 해당 데이터가 없어서 DRAM에서 가져와야 한다면 캐시 미스라 부릅니다. 캐시 미스 발생시의 처리 방법은 캐시 정책에 따라 다르며, 데이터를 읽어 오는 시점으로 사용하기도 한다고 합니다.

6. 스케줄링

시스템의 자원을 효율적으로 사용하기 위해 한 프로세스가 CPU를 언제 얼마나 차지할 것인가에 대한 순서나 방법을 결정짓는 작업을 스케줄링이라고 합니다.
CPU는 한번에 한가지의 작업만을 처리가 가능하므로 여러 프로그램이 번갈아 수행되도록 스케줄링을 사용합니다.



7. 라운드 로빈, LRU, MRU

라운드 로빈
라운드 로빈 스케줄링이란 스케줄링의 한 방법입니다.
 우선순위 스케줄링의 단점을 보완하기위한 것이 라운드 로빈 기법 입니다.
 왜냐하면 우선순위 스케줄링은 순위가 낮은 프로세스들은 무작정 대기를 해야 하며 CPU를 계속 기다리고 있어야 하기 때문입니다.

 라운드 로빈 스케줄링은 프로세스가 하나 끝날때까지 CPU를 가지고 있는게 아니라 , 할당된 시간만큼 돌아가며 처리하는 방식입니다.
 라운드 로빈은 대부분의 시스템에서 사용하고있는 방식이라고 합니다.

LRU
LRU 알고리즘은 Least Recently Used(최근 최소 사용)의 약자로 기억장치 바깥으로 내보내야할 페이지를 선정할 때 가장 오랜 기간 사용되지 않았던 페이지부터 교체하는 페이지 교체 알고리즘 입니다. 이는 일반적으로 가장 오랫동안 액세스 되지 않았던 페이지는 앞으로도 액세스 되지 않을 확률이 제일 크다는 것에 기반한 것이라고 합니다.

덧붙여서 페이지 교체 알고리즘이란 페이지 부재가 발생하였을 때, 주기억장치의 모든 페이지 프레임이 사용중이라면 어떤 페이지 프레임을 선택하여 교체할것인지 결정하는 것을 말한다고 합니다.

MRU(Most Recently Used) ; 가장 최근 사용

덧붙여서 MRU list 란 가장 최근에 사용된 작업 목록을 레지스트리에 저장해두는 기능입니다.

8. 선점, 비선점

스케줄링의 종류에는 비선점 스케줄링과 선점 스케줄링이 있습니다.
비선점 스케줄링은 CPU를 할당받은 프로세스가 종료되기 전까지 CPU 할당을 보장하는 것이고, 선점 스케줄링은 우선 순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있다고 합니다.
비선점 스케줄링은 모든 프로세스의 요구를 공정히 처리할 수 있으며 응답시간이 예측 가능한 반면에 짧은 작업이 긴 작업을 기다리는 경우가 발생할 수 있습니다.
선점 스케줄링은 빠른 응답시간을 요구하는 시분할 시스템에 유용하지만 많은 오버헤드(=어떤 처리를 하기 위해 들어가는 간접적인 처리 시간이나 메모리)를 초래합니다.


9. 메모리 할당, 파편화

메모리 할당이란 어떤 메모리 공간을 임의로 사용할 수 있도록 주는 것입니다.
메모리 할당에는 정적 메모리 할당, 동적 메모리 할당이 있습니다.
정적 메모리 할당은 선언과 동시에 크기가 정해지며 중간에 바꿀 수 없습니다.
소멸할 때 자동으로 할당한 메모리를 회수합니다.
동적 메모리 할당은 정적 메모리 할당과는 달리 프로그램의 중간에 메모리가 허용하는 범위내에서 원하는 만큼 메모리를 할당 받고 사용하고, 그 크기를 중간에 얼마든지 바꿀 수 있습니다.


파편화는 유독 안드로이드 파편화에 관련한 기사들을 많이 보았는데,
더욱이 IOS나 컴퓨터 OS인 윈도우에서도 발생하는 사항이며,
여러 버전이 점유율을 '분할'하고 있는 현상을 말하는 것 같습니다.

10. 물리 메모리, 논리 메모리, 프레임

물리 메모리란 물리적으로 존재하는 메모리입니다.
논리 메모리는 운영 체제가 해당 메인 스토리지로 감지하는 논리 파티션에 지정된 주소 공간입니다.
프레임이란 어떤 대상, 객체에 대한 여러 개의 상황정보들을 하나의 구조화된 틀로서 표현할 수 있는 자료구조입니다.


11. 가상 메모리, 페이징

 가상 메모리는 실제 메모리를 보조해주는 역할을 하며, 가상의 메모리 공간입니다.
 프로세스들이 존재하는 메모리가 여유가 없이 지나치게 많은 요구에 의해 오염될 경우 프로그램의 논리와 무관하게 오류가 나는데 이를 방지하기 위한 기술이 가상 메모리라고 합니다.
 가상 메모리는 메인 메모리의 효율적인 관리, 메모리 관리의 단순화, 메모리 보장의 기능적 역할을 합니다.


페이징이란 가상 메모리 구현 방식의 하나로서, 메모리를 페이지(page)라는 최소 단위로 분할하고 각 프로세스마다 페이지 테이블(page table)을 두어 프로세스의 가상 메모리 상의 페이지들과 실제 물리 메모리 상의 페이지(frame) 사이에 매핑을 정의해 놓는 방식이라고 합니다.

덧붙여서 매핑(mapping)이란 키(key)와 값(value)의 쌍을 이용해 데이터를 관리하는 구조이며, 이렇게 두 객체를 연결하는 것을 매핑이라고 합니다.(딕셔너리와는 다르고, 딕셔너리는 객체 저장이 가능한 컨테이너)